<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <div id="pnlAssetManager" class="picker-wrapper align-items-stretch flex-nowrap" :style="wrapperStyles">
        <div class="picker-folders d-flex flex-column bg-body p-3 mh-100 position-relative flex-shrink-0">
            <!-- TODO What to do with these? -->
            <input type="hidden" name="hfScriptInitialized" id="hfScriptInitialized" value="True">
            <input type="hidden" name="hfSelectedValue" id="hfSelectedValue">
            <input class="js-assetstorage-id" type="hidden" name="hfAssetStorageId" id="hfAssetStorageId" value="1">
            <input class="js-selectfolder" type="hidden" name="hfSelectFolder" id="hfSelectFolder" value="~/Content/ExternalSite/Icons/">
            <input class="js-expandedFolders" type="hidden" name="hfExpandedFolders" id="hfExpandedFolders" value="1,~/Content/,True||1,~/Content/ExternalSite/">
            <input class="js-isroot" type="hidden" name="hfIsRoot" id="hfIsRoot" value="false">

            <div class="mb-3 d-flex flex-shrink-0">
                <RockButton type="button" btnSize="xs" class="mr-2" title="Create a new folder in the selected folder" @click="showAddFolderForm" :disabled="!isFolderSelected">
                    <i class="fa fa-folder-plus"></i> <span class="hidden-xs">Add Folder</span>
                </RockButton>
                <RockButton type="button" btnSize="xs" title="Refresh folder list" isSquare class="ml-auto mr-2" @click="onRefreshFolders">
                    <!-- TODO -->
                    <i class="fa fa-sync"></i>
                </RockButton>
                <DropDownMenu :items="folderDropDownMenuItems" align="right" class="d-flex">
                    <template #anchor="anchorAttrs">
                        <RockButton type="button" btnSize="xs" title="Additional Actions" isSquare :disabled="!isFolderSelected || isRootSelected || isFolderRestricted" v-bind="anchorAttrs">
                            <i class="fa fa-ellipsis-v"></i>
                        </RockButton>
                    </template>
                </DropDownMenu>
            </div>

            <RockForm v-if="isCreateFolderFormVisible" class="mb-3 well well-sm js-createfolder-div flex-shrink-0" @submit="addFolder" @keyup.esc="hideAddFolder">
                <NotificationBox v-if="addFolderError" alertType="danger" heading="Error Creating Folder" #details>
                    {{ addFolderError }}
                </NotificationBox>
                <TextBox v-model="newFolderName" size="small" label="Folder Name" :rules="addFolderValidation" help="Cannot contain any of the following characters: ^ * > < ? / \ | : , ~" />
                <RockButton type="submit" btnSize="xs" class="mr-2" :disabled="!newFolderName">
                    <i class="fa fa-check"></i> Create Folder
                </RockButton>
                <RockButton @click="hideAddFolder" type="button" btnSize="xs">
                    <i class="fa fa-times"></i> Cancel
                </RockButton>
            </RockForm>

            <div v-if="folderListScrolled" class="scroll-shadow"></div>

            <div ref="folderScrollContainer" class="overflow-y-auto overflow-x-auto mh-100" style="z-index:0">
                <NotificationBox v-if="deleteFolderError" alertType="danger" heading="Error Deleting Folder" dismissible @dismiss="deleteFolderError = ''" #details>
                    {{ deleteFolderError }}
                </NotificationBox>
                <TreeList v-model="selectedFolderArray"
                          :provider="itemProvider"
                          v-model:items="folders"
                          disableDeselect
                          autoExpand
                          @treeitem-expanded="onTreeItemExpanded"
                          @treeitem-collapsed="onTreeItemCollapsed"
                          :initiallyExpanded="openFolders"
                          :key="treeRefreshKey" />
            </div>

            <Transition>
                <div v-if="isFolderPaneActionLoading" class="d-flex flex-column justify-content-center inset-0 bg-body loader-overlay">
                    <LoadingIndicator />
                </div>
            </Transition>
        </div>

        <div class="picker-files d-flex flex-column p-3 mh-100 flex-shrink-0 position-relative">
            <div class="mb-3 d-flex align-items-center">
                <div v-if="isUploadingFile" class="js-upload-progress upload-progress-sm">
                    <!-- TODO -->
                    <i class="fa fa-refresh fa-lg fa-spin"></i>
                </div>
                <label class="btn btn-xs btn-default mr-2" title="Upload a file to the selected location." v-bind="isUploadDisabled ? { disabled: true } : {}">
                    <i class="fa fa-upload"></i> <span class="hidden-xs">Upload File</span>
                    <!-- TODO -->
                    <input type="file" ref="fileInputElement" class="hidden" @change="uploadFile" :disabled="isUploadDisabled">
                </label>
                <label class="btn btn-xs btn-default mr-2" v-if="enableFileManager && enableZipUpload" v-bind="isZipUploadDisabled ? { disabled: true } : {}">
                    <i class="fa fa-archive"></i> <span class="hidden-xs">Upload Package</span>
                    <!-- TODO -->
                    <input type="file" ref="zipFileInputElement" class="hidden" accept=".zip" @change="uploadZipFile" :disabled="isZipUploadDisabled">
                </label>
                <RockButton type="button" btnSize="xs" title="Delete selected files" class="mr-2" :disabled="selectedFileKeys.length < 1" @click="deleteFiles(selectedFileKeys)">
                    <i class="fa fa-trash-alt"></i> <span class="hidden-xs">Delete Selected</span>
                </RockButton>
                <RockButton type="button" btnSize="xs" title="Refresh file list" class="ml-auto" @click="refreshFiles">
                    <i class="fa fa-sync"></i>
                </RockButton>
            </div>

            <NotificationBox v-if="fileListErrorMessage" alertType="danger" :heading="`Error ${fileListErrorAction}`" dismissible @dismiss="fileListErrorMessage = ''" #details>
                {{ fileListErrorMessage }}
            </NotificationBox>

            <div v-if="fileListScrolled" class="scroll-shadow"></div>

            <div class="overflow-y-auto mh-100 flex-grow-1 d-flex align-items-start" ref="fileScrollContainer">
                <table v-if="files.length > 0" class="table table-responsive table-borderless assetmanager-files">
                    <tbody>
                        <tr v-for="file in files" :key="file.key">
                            <td>
                                <CheckBox label="" v-model="selectedFileKeys" :value="file.key" />
                            </td>
                            <td>
                                <img :src="file.iconPath" style="object-fit: cover; height: 58px; width: 44px;">
                            </td>
                            <td>
                                <span v-show="shownFileRenameForm != file.key">{{ file.name }}</span>
                                <RockForm class="d-flex align-items-center" v-if="shownFileRenameForm == file.key" @submit="() => renameFile(file)" @keyup.esc="hideRenameFileForm">
                                    <TextBox v-model="renameFileName" size="small" formGroupClasses="mr-2 mb-0" disableLabel id="asset-manager-current-file-rename-input" />
                                    <RockButton type="submit" btnType="default" btnSize="xs" class="mr-2 flex-shrink-0" title="Rename File" isSquare><i class="fa fa-check"></i></RockButton>
                                    <RockButton type="button" btnType="default" btnSize="xs" class="flex-shrink-0" title="Cancel" isSquare @click="hideRenameFileForm"><i class="fa fa-times"></i></RockButton>
                                </RockForm>
                            </td>
                            <td data-priority="3">
                                {{ formatDate(file.lastModifiedDateTime) }}
                            </td>
                            <td>
                                {{ file.formattedFileSize }}
                            </td>
                            <td>
                                <!-- TODO -->
                                <DropDownMenu :items="getFileDropDownMenuItems(file)" align="right" class="d-flex">
                                    <template #anchor="anchorAttrs">
                                        <RockButton type="button" btnType="link" class="text-body" v-bind="anchorAttrs"><i class="fa fa-ellipsis-v"></i></RockButton>
                                    </template>
                                </DropDownMenu>
                            </td>
                        </tr>
                    </tbody>
                </table>
                <div v-else-if="!isFolderSelected" class="m-auto justify-self-center text-lg text-muted" style="width:max-content;">Please select a folder.</div>
                <div v-else-if="!isLoadingFiles" class="m-auto justify-self-center text-lg text-muted" style="width:max-content;">No files found.</div>
            </div>

            <Transition>
                <div v-if="isFilePaneActionLoading" class="d-flex flex-column justify-content-center inset-0 bg-body loader-overlay">
                    <LoadingIndicator />
                </div>
            </Transition>
        </div>
    </div>
</template>

<style scoped>
.assetmanager-files th,
.assetmanager-files td {
    vertical-align: middle;
}

.scroll-shadow {
    height: 1px;
    background: transparent;
    box-shadow: 0 0 7px black;
    clip-path: rect(0 0 10px 100%);
    flex-shrink: 0;
    /* Prevents hover highlights of list items from going over the shadow */
    z-index: 1;
}

.table-borderless th,
.table-borderless td {
    border: 0;
}

.loader-overlay {
    opacity: 0.5;
}


.v-enter-active {
    transition: opacity .5s ease-in;
}

.v-leave-active {
    transition: opacity .15s ease-in-out;
}

.v-enter-from,
.v-leave-to {
    opacity: 0;
}
</style>

<script setup lang="ts">
    import { PropType, computed, nextTick, ref, watch } from "vue";
    import RockButton from "./rockButton.obs";
    import RockForm from "./rockForm.obs";
    import TextBox from "./textBox.obs";
    import CheckBox from "./checkBox.obs";
    import TreeList from "./treeList.obs";
    import LoadingIndicator from "./loadingIndicator.obs";
    import DropDownMenu from "./dropDownMenu.obs";
    import NotificationBox from "./notificationBox.obs";
    import { useVModelPassthrough } from "@Obsidian/Utility/component";
    import { AssetManagerTreeItemProvider } from "@Obsidian/Utility/treeItemProviders";
    import { AssetManagerTreeItemBag } from "@Obsidian/ViewModels/Rest/Controls/assetManagerTreeItemBag";
    import { AssetManagerBaseOptionsBag } from "@Obsidian/ViewModels/Rest/Controls/assetManagerBaseOptionsBag";
    import { AssetManagerAddFolderOptionsBag } from "@Obsidian/ViewModels/Rest/Controls/assetManagerAddFolderOptionsBag";
    import { AssetManagerGetFilesOptionsBag } from "@Obsidian/ViewModels/Rest/Controls/assetManagerGetFilesOptionsBag";
    import { AssetManagerGetFilesResultsBag } from "@Obsidian/ViewModels/Rest/Controls/assetManagerGetFilesResultsBag";
    import { AssetManagerDeleteFilesOptionsBag } from "@Obsidian/ViewModels/Rest/Controls/assetManagerDeleteFilesOptionsBag";
    import { AssetManagerRenameFileOptionsBag } from "@Obsidian/ViewModels/Rest/Controls/assetManagerRenameFileOptionsBag";
    import { FileAsset } from "@Obsidian/ViewModels/Controls/fileAsset";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { TreeItemBag } from "@Obsidian/ViewModels/Utility/treeItemBag";
    import { useHttp } from "@Obsidian/Utility/http";
    import { findFolder, folderNameComparator, isValidFolderName } from "@Obsidian/Utility/assetProvider";
    import { MenuAction } from "@Obsidian/Types/Controls/dropDownMenu";
    import { RockDateTime, DateTimeFormat } from "@Obsidian/Utility/rockDateTime";
    import { ValidationRule } from "@Obsidian/ValidationRules";
    import { uploadAssetProviderFile } from "@Obsidian/Utility/http";

    const props = defineProps({
        modelValue: {
            type: Object as PropType<FileAsset[]>,
        },

        openFolders: {
            type: Array as PropType<string[]>,
            default: () => [],
        },

        /**
         * "flexible" will make the height grow as the number of files/folder show grows.
         * Otherwise pass in a CSS height value.
         * Default: "flexible"
         */
        height: {
            type: String as PropType<string | "flexible">,
            default: "flexible",
        },

        enableAssetManager: {
            type: Boolean,
            default: false
        },

        enableFileManager: {
            type: Boolean,
            default: false
        },

        /** The encrypted root folder used for the local file browser */
        encryptedRootFolder: String,

        enableZipUpload: {
            type: Boolean,
            default: true
        }
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: ListItemBag): void
        (e: "update:openFolders", value: string[]): void
    }>();

    const internalValue = useVModelPassthrough(props, "modelValue", emit);
    const { post } = useHttp();

    // #region Styles

    const wrapperStyles = computed(() => {
        if (props.height === "flexible") {
            return {};
        }
        else {
            return {
                height: props.height,
            };
        }
    });

    // #endregion

    // #region Folder List

    const itemProvider = ref(initializeTreeProvider());
    const openFolders = computed(() => Array.from(itemProvider.value.openFolders));
    const folders = ref<AssetManagerTreeItemBag[]>([]);

    const selectedFolderArray = ref<string[]>([]);
    const selectedFolder = computed<string | null>(() => decodeURIComponent(selectedFolderArray.value[0] ?? "") || null);
    const isFolderSelected = computed(() => !!selectedFolder.value);
    const isRootSelected = computed(() => isFolderSelected.value && selectedFolder.value?.endsWith(",True"));

    const isFolderRestricted = ref(false);

    const isFolderPaneActionLoading = ref(false);
    const folderScrollContainer = ref<HTMLElement | null>(null);
    const folderListScrolled = ref(false);

    const isCreateFolderFormVisible = ref(false);
    const newFolderName = ref("");
    const addFolderError = ref("");

    const deleteFolderError = ref("");
    const treeRefreshKey = ref(1);

    const addFolderValidation: ValidationRule[] = [
        "required",
        (val: unknown) => isValidFolderName(val as string) ? true : "contains invalid characters: Do not use the following characters: ^ * > < ? / \\ | : , ~",
    ];

    const folderDropDownMenuItems = computed<MenuAction[]>(() => {
        return [{
            title: "Rename",
            type: "default",
            handler: () => console.log("RENAME"), // TODO
            disabled: true // TODO
        }, {
            title: "Move",
            type: "default",
            handler: () => console.log("MOVE"), // TODO
            disabled: true // TODO
        },
        {
            title: "Delete",
            type: "danger",
            handler: () => {
                deleteSelectedFolder(); /* Explicitly don't return promise so dropdown will hide immediately */
            }
        }];
    });

    function showAddFolderForm(): void {
        isCreateFolderFormVisible.value = true;
    }

    async function addFolder(): Promise<void> {
        newFolderName.value = newFolderName.value.trim();
        addFolderError.value = "";

        isFolderPaneActionLoading.value = true;

        const options: AssetManagerAddFolderOptionsBag = {
            assetFolderId: selectedFolder.value,
            newFolderName: newFolderName.value
        };
        const url = "/api/v2/Controls/AssetManagerAddFolder";
        const response = await post<AssetManagerTreeItemBag>(url, undefined, options);

        if (response.isSuccess && response.data) {
            hideAddFolder();
            const { folder } = findFolder(folders.value, selectedFolder.value);
            if (folder) {
                if (!folder.children) {
                    folder.children = [];
                }
                folder.hasChildren = true;
                folder.children.push(response.data);
                folder.children.sort(folderNameComparator);
                // Reassign so Vue sees the change (push and sort didn't trigger reactivity)
                folder.children = folder.children; // eslint-disable-line no-self-assign
            }
        }
        else {
            addFolderError.value = response.errorMessage || "An unknown error occurred while adding the folder.";
        }

        isFolderPaneActionLoading.value = false;
    }

    function hideAddFolder(): void {
        isCreateFolderFormVisible.value = false;
        newFolderName.value = "";
        addFolderError.value = "";
    }

    async function deleteSelectedFolder(): Promise<void> {
        isFolderPaneActionLoading.value = true;

        const options: AssetManagerBaseOptionsBag = {
            assetFolderId: selectedFolder.value
        };
        const url = "/api/v2/Controls/AssetManagerDeleteFolder";
        const response = await post<boolean>(url, undefined, options);

        if (response.data) {
            const { parent, index } = findFolder(folders.value, selectedFolder.value);

            if (parent && parent.children && index !== -1) {
                parent.children.splice(index, 1);
                parent.hasChildren = parent.children.length > 0;
            }

            selectedFolderArray.value = [];
        }
        else {
            deleteFolderError.value = response.errorMessage || "An unknown error occurred while deleting the folder.";
        }

        isFolderPaneActionLoading.value = false;
    }

    function onTreeItemExpanded(item: TreeItemBag): void {
        itemProvider.value.openFolders.add(item.value ?? "");
    }

    function onTreeItemCollapsed(item: TreeItemBag): void {
        itemProvider.value.openFolders.delete(item.value ?? "");
    }

    function areSetsEqual(as: Set<any>, bs: Set<any>): boolean { // eslint-disable-line @typescript-eslint/no-explicit-any
        if (as.size !== bs.size) {
            return false;
        }
        for (const a of as) {
            if (!bs.has(a)) {
                return false;
            }
        }
        return true;
    }

    function onRefreshFolders(): void {
        treeRefreshKey.value++;
    }

    function parseFolderName(key: string): { providerId: string, folderPath: string } {
        const { folder } = findFolder(folders.value, key);

        const parts = key.split(",");

        if (parts.length >= 3) {
            let root = (folder as AssetManagerTreeItemBag).unencryptedRoot;

            if (root == "/") {
                root = "";
            }

            return {
                providerId: parts[0],
                folderPath: root + parts[2]
            };
        }
        else {
            return {
                providerId: "",
                folderPath: ""
            };
        }
    }

    function initializeTreeProvider(): AssetManagerTreeItemProvider {
        const provider = new AssetManagerTreeItemProvider();
        provider.openFolders = new Set(props.openFolders);
        provider.enableAssetManager = props.enableAssetManager;
        provider.enableFileManager = props.enableFileManager;
        provider.encryptedRootFolder = props.encryptedRootFolder || "";

        return provider;
    }

    watch(() => props.openFolders, () => {
        const newList = new Set(props.openFolders);

        if (!areSetsEqual(newList, itemProvider.value.openFolders)) {
            itemProvider.value.openFolders = newList;
        }
    });

    watch(itemProvider, () => {
        emit("update:openFolders", Array.from(itemProvider.value.openFolders));
    }, { deep: true });

    /**
     * Show a shadow at the top of the file list when it is scrolled, making it looks like it's
     * sitting underneath the action bar.
     */
    watch(folderScrollContainer, () => {
        if (folderScrollContainer.value) {
            folderScrollContainer.value.addEventListener("scroll", () => {
                folderListScrolled.value = (folderScrollContainer.value?.scrollTop ?? 0) > 0;
            });
        }
        else {
            folderListScrolled.value = false;
        }
    });

    watch(() => [props.enableAssetManager, props.enableFileManager, props.encryptedRootFolder], () => {
        itemProvider.value = initializeTreeProvider();
    });

    // #endregion

    // #region File List

    const selectedFileKeys = ref<string[]>([]);
    const files = ref<FileAsset[]>([]);
    const isLoadingFiles = ref(false);

    const fileScrollContainer = ref<HTMLElement | null>(null);
    const fileListScrolled = ref(false);

    const shownFileRenameForm = ref<string | null>(null);
    const renameFileName = ref("");

    const isUploadRestricted = ref(false);
    const isUploadingFile = ref(false);
    const fileInputElement = ref<HTMLInputElement | null>(null);
    const zipFileInputElement = ref<HTMLInputElement | null>(null);

    const isUploadDisabled = computed(() => !isFolderSelected.value || isUploadingFile.value || isLoadingFiles.value);
    const isZipUploadDisabled = computed(() => isUploadDisabled.value || isUploadRestricted.value);

    const isFilePaneActionLoading = ref(false);

    const fileListErrorMessage = ref("");
    const fileListErrorAction = ref("");

    async function showRenameFileForm(file: FileAsset): Promise<void> {
        shownFileRenameForm.value = file.key;
        renameFileName.value = file.name;

        await nextTick();

        const inputField = document.querySelector(`#asset-manager-current-file-rename-input`) as HTMLInputElement;

        if (inputField) {
            inputField.focus();
            const baseFileName = getBaseFileName(file.name);
            inputField.setSelectionRange(0, baseFileName.length);
        }
    }

    async function renameFile(file): Promise<void> {
        fileListErrorAction.value = "";
        fileListErrorMessage.value = "";

        try {
            isFilePaneActionLoading.value = true;
            const { providerId } = parseFolderName(selectedFolder.value ?? "");

            const url = "/api/v2/Controls/AssetManagerRenameFile";
            const options: AssetManagerRenameFileOptionsBag = {
                file: file.key,
                assetStorageProviderId: Number(providerId),
                newFileName: renameFileName.value
            };

            const response = await post<boolean>(url, undefined, options);

            if (response.isSuccess && response.data) {
                hideRenameFileForm();
            }
            else {
                throw response.errorMessage;
            }
        }
        catch (e) {
            fileListErrorMessage.value = (e as Error).message || "An unknown error occurred while renaming the file.";
            fileListErrorAction.value = "Renaming File";
        }
        finally {
            isFilePaneActionLoading.value = false;
            refreshFiles();
        }
    }

    function hideRenameFileForm(): void {
        shownFileRenameForm.value = null;
        renameFileName.value = "";
    }

    async function uploadFile(): Promise<void> {
        fileListErrorAction.value = "";
        fileListErrorMessage.value = "";

        if (isUploadingFile.value) {
            return;
        }

        try {
            isUploadingFile.value = true;

            if (fileInputElement.value && fileInputElement.value.files && fileInputElement.value.files.length > 0) {
                const { providerId, folderPath } = parseFolderName(selectedFolder.value ?? "");

                await uploadAssetProviderFile(fileInputElement.value.files[0], folderPath, providerId);
                refreshFiles();
            }
        }
        catch (e) {
            fileListErrorMessage.value = (e as Error).message ?? "An unknown error occurred while uploading the file.";
            fileListErrorAction.value = "Uploading File";
        }
        finally {
            fileInputElement.value!.files = null;
            isUploadingFile.value = false;
        }
    }

    function uploadZipFile(): void {
        // TODO
        console.log("UPLOAD ZIP FILE");
    }

    async function deleteFiles(files: string[]): Promise<void> {
        fileListErrorAction.value = "";
        fileListErrorMessage.value = "";

        try {
            isFilePaneActionLoading.value = true;
            const { providerId } = parseFolderName(selectedFolder.value ?? "");

            const url = "/api/v2/Controls/AssetManagerDeleteFiles";
            const options: AssetManagerDeleteFilesOptionsBag = {
                files,
                assetStorageProviderId: Number(providerId)
            };

            const response = await post<TreeItemBag>(url, undefined, options);

            if (response.isSuccess && response.data) {
                // Empty: Nothing to do, except what's already being done in the `finally` block
            }
            else {
                throw response.errorMessage;
            }
        }
        catch (e) {
            fileListErrorMessage.value = (e as Error).message || "An unknown error occurred while deleting the file(s).";
            fileListErrorAction.value = "Deleting File";
        }
        finally {
            isFilePaneActionLoading.value = false;
            refreshFiles();
        }
    }

    function refreshFiles(): void {
        fetchFiles();
    }

    function resetFileState(): void {
        shownFileRenameForm.value = null;
        selectedFileKeys.value = [];
        files.value = [];
    }

    async function fetchFiles(): Promise<void> {
        resetFileState();
        isLoadingFiles.value = true;
        isFilePaneActionLoading.value = true;

        const options: AssetManagerGetFilesOptionsBag = {
            assetFolderId: selectedFolder.value,
            browseMode: "doc" // TODO: add prop and pass in. Make prop reactive to refetch files
        };
        const url = "/api/v2/Controls/AssetManagerGetFiles";
        const response = await post<AssetManagerGetFilesResultsBag<FileAsset>>(url, undefined, options);

        if (response.isSuccess && response.data) {
            files.value = response.data.files ?? [];
            isFolderRestricted.value = response.data.isFolderRestricted ?? false;
            isUploadRestricted.value = response.data.isFolderUploadRestricted ?? false;
        }

        isLoadingFiles.value = false;
        isFilePaneActionLoading.value = false;
    }

    function getFileDropDownMenuItems(file: FileAsset): MenuAction[] {
        // TODO: Detect file type and return appropriate menu items
        // editUrl = editFilePage + "?RelativeFilePath=" + UrlEncode( file.key );

        return [{
            //     title: "Edit",
            //     type: "default",
            //     handler: () => console.log("Edit"), // TODO
            //     disabled: false // TODO
            // }, {
            title: "Download",
            type: "default",
            handler: () => {
                // Since this returns a download stream, we never actually navigate away from the page
                window.location.href = `/api/v2/Controls/AssetManagerDownloadFile?file=${encodeURI(file.key)}&assetStorageProviderId=${parseFolderName(selectedFolder.value ?? "").providerId}`;
            },
            disabled: false
        }, {
            title: "Rename",
            type: "default",
            handler: () => showRenameFileForm(file),
            disabled: false
        }, {
            title: "Delete",
            type: "danger",
            handler: () => {
                deleteFiles([file.key]); /* Explicitly don't return promise so dropdown will hide immediately */
            }
        }];
    }

    /**
     * Gets the name of the file without the extension
     */
    function getBaseFileName(fileName: string): string {
        // Regex captures two parts. The first part is the base name and the second is a dot
        // followed by at least 1 non-dot character at the end of the string.
        const parser = /(.*)(\.[^.]+)$/;

        // For example "file.name.ext" would return ["file.name.ext", "file.name", ".ext"]
        const results = parser.exec(fileName);

        // If we have anything in the base name capture element, return it.
        if (results && results[1]) {
            return results[1];
        }

        // If we couldn't parse out the base, just return the entire file name.
        return fileName;
    }

    watch(selectedFileKeys, () => {
        internalValue.value = files.value.filter(f => selectedFileKeys.value.includes(f.key));
    });

    watch(selectedFolder, () => {
        if (selectedFolder.value) {
            fetchFiles();
        }
        else {
            files.value = [];
        }
    });

    /**
     * Show a shadow at the top of the file list when it is scrolled, making it looks like it's
     * sitting underneath the action bar.
     */
    watch(fileScrollContainer, () => {
        if (fileScrollContainer.value) {
            fileScrollContainer.value.addEventListener("scroll", () => {
                fileListScrolled.value = (fileScrollContainer.value?.scrollTop ?? 0) > 0;
            });
        }
        else {
            fileListScrolled.value = false;
        }
    });

    // #endregion

    // #region Date/Time

    const dateCache: { [key: string]: string } = {};

    function formatDate(date: string): string {
        if (!date) {
            return "";
        }

        if (dateCache[date]) {
            return dateCache[date];
        }

        const formattedDate = RockDateTime
            .parseISO(date)
            ?.toLocaleString(DateTimeFormat.DateTimeShort);

        if (formattedDate) {
            dateCache[date] = formattedDate;
        }

        return formattedDate ?? "";
    }

    // #endregion

</script>
