<template>
    <ColorPicker v-model="borderColor" label="Color" />

    <NumberUpDown v-model="borderRadius"
                  label="Corner Radius"
                  :min="0"
                  :max="99" />

    <DropDownList v-model="borderStyle"
                  :items="borderStyles"
                  label="Style" />

    <NumberUpDown v-model="height"
                  label="Thickness"
                  :min="0"
                  :max="99" />

    <NumberUpDown v-model="marginTop"
                  label="Vertical Margin Size"
                  :min="0"
                  :max="99" />
</template>

<script setup lang="ts">
    import { computed, PropType, ref, watch } from "vue";
    import { ColorPicker, DropDownList, NumberUpDown } from "../imports.partial";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";

    const props = defineProps({
        modelValue: {
            type: Object as PropType<HTMLElement>,
            required: true
        }
    });

    // IMPORTANT! These values will be used as is in the rendered CSS Ruleset.
    // If quotes are required, add them here.
    const borderStyles: ListItemBag[] = [
        {
            value: "solid",
            text: "Solid"
        }, {
            value: "dashed",
            text: "Dashed"
        }, {
            value: "dotted",
            text: "Dotted"
        }
    ];

    const tagName: keyof HTMLElementTagNameMap = "hr";

    // #region Values

    // These are initialized in the "immediate" props.modelValue watcher below.
    const borderColor = ref<string>("");
    const borderRadius = ref<number>(0);
    const borderStyle = ref<string>("");
    const height = ref<number>(0);
    const marginTop = ref<number>(0);

    // #endregion

    // #region Computed Values

    const cssRuleset = computed<string | null>(() => {
        const declarations: string[] = [];

        if (borderColor.value) {
            declarations.push(`border-color: ${borderColor.value};`);
            declarations.push(`background-color: ${borderColor.value};`);
        }

        if (borderRadius.value) {
            declarations.push(`border-radius: ${borderRadius.value}px;`);
        }

        if (borderStyle.value) {
            declarations.push(`border-style: ${borderStyle.value};`);
        }

        if (height.value) {
            declarations.push(`height: ${height.value}px;`);

            // Make sure the border thickness is included in the overall divider height.
            declarations.push(`box-sizing: border-box;`);
        }

        if (marginTop.value) {
            declarations.push(`margin-top: ${marginTop.value}px;`);
        }

        if (declarations.length) {
            return `${tagName} {\n    ${declarations.join("\n    ")}\n}`;
        }
        else {
            return null;
        }
    });

    // #endregion

    // #region Watchers

    watch(() => props.modelValue, () => {
        const ownerDocument = props.modelValue.ownerDocument;
        const ownerWindow = ownerDocument.defaultView;

        if (!ownerWindow) {
            throw "The element is not a child of an active window";
        }

        let loaded = false;
        for (const stylesheet of props.modelValue.ownerDocument.styleSheets) {
            const ownerNode = stylesheet.ownerNode;

            if (ownerNode instanceof ownerWindow.HTMLStyleElement) {
                if (ownerNode.classList.contains(`rock-design-${tagName}`)) {
                    for (const rule of stylesheet.cssRules) {
                        if (rule instanceof ownerWindow.CSSStyleRule) {
                            if (rule.selectorText === tagName) {
                                borderColor.value = rule.style.borderColor;
                                borderRadius.value = parseInt(rule.style.borderRadius || "0");
                                borderStyle.value = rule.style.borderStyle;
                                height.value = parseInt(rule.style.height || "0");
                                marginTop.value = parseInt(rule.style.marginTop || "0");

                                loaded = true;
                            }
                        }
                    }
                }
            }
        }

        if (!loaded) {
            borderColor.value = "";
            borderRadius.value = 0;
            borderStyle.value = "";
            height.value = 0;
            marginTop.value = 0;
        }
    }, {
        // Since the reactive values are not initialized where defined above,
        // this needs to be immediate here.
        immediate: true
    });

    // Whenever the CSS ruleset changes based on the font properties,
    // the style tag associated with this component's bound element
    // should be added/updated with the new styles.
    watch(cssRuleset, () => {
        if (cssRuleset.value) {
            const tag = props.modelValue.querySelector(`style.rock-design-${tagName}`);
            const styleTag = props.modelValue.ownerDocument.createElement("style");
            styleTag.textContent = cssRuleset.value;
            styleTag.classList.add(`rock-design-${tagName}`);
            if (tag) {
                tag.replaceWith(styleTag);
            }
            else {
                props.modelValue.append(styleTag);
            }
        }
        else {
            const tag = props.modelValue.querySelector(`style.rock-design-${tagName}`);
            if (tag) {
                tag.remove();
            }
        }
    });

    // #endregion
</script>
