<template>
    <template v-if="selectedComponent.componentElement">
        <Panel :hasCollapse="true"
               :modelValue="true"
               title="Row Settings">
            <ElementBackgroundColor :modelValue="selectedComponent.componentElement" />
            <ElementBorderWidth :modelValue="selectedComponent.componentElement" />
            <ElementBorderColor :modelValue="selectedComponent.componentElement" />
        </Panel>

        <Panel :hasCollapse="true"
               title="Columns">
            <ElementBackgroundColor :modelValue="selectedComponent.componentElement" />
            <ElementBorderWidth :modelValue="selectedComponent.componentElement" />
            <ElementBorderColor :modelValue="selectedComponent.componentElement" />
        </Panel>
    </template>
</template>

<script setup lang="ts">
    import { PropType, ref, watch } from "vue";
    import ElementBackgroundColor from "./properties/elementBackgroundColor.partial.obs";
    import ElementBorderColor from "./properties/elementBorderColor.partial.obs";
    import ElementBorderWidth from "./properties/elementBorderWidth.partial.obs";
    import { EditorComponent } from "./types.partial";
    import Panel from "@Obsidian/Controls/panel.obs";

    const props = defineProps({
        selectedComponent: {
            type: Object as PropType<EditorComponent>,
            required: true
        }
    });

    // #region Values

    const backgroundColor = ref<string>(props.selectedComponent?.componentElement.style.backgroundColor ?? "");
    const borderWidth = ref<number>(parseInt(props.selectedComponent?.componentElement.style.borderWidth || "0"));
    const borderColor = ref<string>(props.selectedComponent?.componentElement.style.borderColor ?? "");
    const panels = ref<boolean[]>([true, false]);

    // #endregion

    // #region Event Handlers

    function onUpdateBackgroundColor(value: string): void {
        backgroundColor.value = value;

        if (props.selectedComponent?.componentElement) {
            props.selectedComponent.componentElement.style.backgroundColor = value;
        }
    }

    function onUpdateBorderWidth(value: number): void {
        borderWidth.value = value;

        if (props.selectedComponent?.componentElement) {
            if (value) {
                props.selectedComponent.componentElement.style.borderWidth = `${value}px`;
                props.selectedComponent.componentElement.style.borderStyle = "solid";
            }
            else {
                props.selectedComponent.componentElement.style.borderWidth = "";
                props.selectedComponent.componentElement.style.borderStyle = "";
            }
        }
    }

    function onUpdateBorderColor(value: string): void {
        borderColor.value = value;

        if (props.selectedComponent?.componentElement) {
            if (value) {
                props.selectedComponent.componentElement.style.borderColor = value;
                props.selectedComponent.componentElement.style.borderStyle = "solid";
            }
            else {
                props.selectedComponent.componentElement.style.borderColor = "";
                props.selectedComponent.componentElement.style.borderStyle = "";
            }
        }
    }

    // #endregion

    // #region Watchers

    watch(() => props.selectedComponent, () => {
        backgroundColor.value = props.selectedComponent?.componentElement.style.backgroundColor ?? "";
    });

    // #endregion
</script>