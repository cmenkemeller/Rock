<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Panel :hasFullscreen="true"
           :headerSecondaryActions="[{
               title: 'TBD', type: 'default'
           }]"
           panelClass="communication-entry-wizard-editor-panel">
        <template #title>
            <div class="communication-entry-wizard-editor-panel-title">
                <span>Email Editor</span>
                <HighlightLabel>1234 Recipients</HighlightLabel>
            </div>
        </template>

        <template #subheaderRight>
            <div>
                <RockButton class="communication-entry-wizard-editor-subheader-action" btnSize="xs">Send Test</RockButton>
                <RockButton class="communication-entry-wizard-editor-subheader-action" btnSize="xs">Preview</RockButton>
                <RockButton class="communication-entry-wizard-editor-subheader-action" btnSize="xs">Save</RockButton>
            </div>
        </template>

        <template #default>
            <div class="communication-entry-wizard-editor-panel-body">
                <div class="communication-entry-wizard-editor-toolbox">
                    <div class="communication-entry-wizard-editor-toolbox-menu">
                        <div class="menu-item menu-item-content selected"><i class="fa fa-grip-horizontal"></i><span>Content</span></div>
                        <div class="menu-item menu-item-design"><i class="fa fa-drafting-compass"></i><span>Design</span></div>
                    </div>

                    <div class="communication-entry-wizard-editor-toolbox-submenu">
                        <TabbedContent v-model="toolboxSubMenuTab" :tabs="toolboxSubMenuTabs">
                            <template #tabpane="{ item }">
                                <div class="px-3">
                                    <div v-if="item === 'Components'" class="component-list">
                                        <div v-for="componentType in componentTypes"
                                             :key="componentType.typeName"
                                             class="component-list-item draggable"
                                             draggable="true"
                                             @dragstart="onComponentTypeDragStart($event, componentType)"
                                             @dragend="onComponentTypeDragEnd($event, componentType)"><i :class="componentType.iconCssClass"></i>{{ componentType.name }}</div>
                                    </div>

                                    <div v-else-if="item === 'Sections'">
                                        <DropDownList v-model="sectionCategory" :items="sectionCategories" label="Category">
                                            <template #inputGroupPrepend>
                                                <div class="input-group-addon">
                                                    <i class="fa fa-folder"></i>
                                                </div>
                                            </template>
                                        </DropDownList>

                                        <div class="section-list">

                                        </div>
                                    </div>
                                </div>
                            </template>
                        </TabbedContent>
                    </div>
                </div>

                <div class="communication-entry-wizard-editor-content-container">
                    <IFrameProjector ref="editorIFrameProjector" :width="editorWidth" :height="editorHeight" frameborder="0" border="0">
                        <!DOCTYPE html>
                        <html>

                        <head>
                        </head>

                        <body>
                            <div style="display: flex; flex-direction: row;">
                                <div class="dropzone" style="flex-grow: 1; background-color: lightblue;">
                                </div>
                                <div class="dropzone" style="flex-grow: 1; background-color: lightseagreen;">
                                </div>
                            </div>
                        </body>

                        </html>
                    </IFrameProjector>
                    <div v-if="isEditorOverlayVisible && draggingComponentType"
                         class="communication-entry-wizard-editor-overlay"
                         @dragover="onComponentTypeDragOver($event, draggingComponentType)"
                         @drop="onComponentTypeDragDrop($event, draggingComponentType)"
                         @dragleave="onComponentTypeDragLeave($event, draggingComponentType)"></div>
                </div>
            </div>
        </template>

        <template #footerActions>
            <RockButton>Previous</RockButton>
        </template>

        <template #footerSecondaryActions>
            <RockButton btnType="primary">Next</RockButton>
        </template>
    </Panel>
</template>

<style scoped>
.communication-entry-wizard-editor-content-container {
    position: relative;
    width: v-bind(editorWidthPixels);
    height: v-bind(editorHeightPixels);
}

.communication-entry-wizard-editor-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: v-bind(editorWidthPixels);
    height: v-bind(editorHeightPixels);
    /* TODO JMH Remove this commented code.
    opacity: 0.4;
    background-color: orange;
     */
}

.draggable {
    cursor: grab;
}

.draggable:active {
    cursor: grabbing;
}

.component-list {
    display: flex;
    flex-direction: row;
    /* TODO JMH Is this supported? */
    gap: 16px;
    flex-wrap: wrap;
}

.component-list-item {
    display: flex;
    flex-direction: column;
    width: 86px;
    height: 74px;
    text-align: center;
    align-items: center;
    border: 1px solid;
    justify-content: center;
}

.component-list-item:active {
    border-color: var(--color-primary);
}

.communication-entry-wizard-editor-toolbox {
    display: flex;
    flex-wrap: wrap;
}

.communication-entry-wizard-editor-toolbox-menu {
    background-color: gray;
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.menu-item {
    display: flex;
    flex-direction: column;
    width: 86px;
    height: 74px;
    text-align: center;
    align-items: center;
    gap: 16px;
    justify-content: center;
    cursor: pointer;
}

.menu-item.selected {
    background-color: white;
}

.communication-entry-wizard-editor-toolbox-submenu {
    display: flex;
    flex-direction: column;
    width: 322px;
}

.communication-entry-wizard-editor-panel-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.communication-entry-wizard-editor-subheader-action + .communication-entry-wizard-editor-subheader-action {
    margin-left: 16px;
}

.communication-entry-wizard-editor-panel-body {
    min-height: 300px;
    display: flex;
}
</style>

<script setup lang="ts">
    import { computed, onBeforeUnmount, onMounted, ref } from "vue";
    import IFrameProjector from "./CommunicationWizard/iframeProjector.partial.obs";
    import { EditorComponentType, EditorComponentTypeName } from "./CommunicationWizard/types.partial";
    import DropDownList from "@Obsidian/Controls/dropDownList.obs";
    import HighlightLabel from "@Obsidian/Controls/highlightLabel.obs";
    import Panel from "@Obsidian/Controls/panel.obs";
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import TabbedContent from "@Obsidian/Controls/tabbedContent.obs";
    import { buttonComponent, dividerComponent, getComponentOrThrow, imageComponent, lavaComponent, messageComponent, paragraphComponent, rsvpComponent, titleComponent, videoComponent } from "./CommunicationWizard/components.partial";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";

    const editorWidth = 500;
    const editorHeight = 500;

    type Coords = {
        x: number;
        y: number;
    };

    type ComponentTypeDragLeavePushMessageEvent = {
        type: "COMPONENT_TYPE_DRAG_LEAVE";
        componentTypeName: EditorComponentTypeName;
    };

    type ComponentTypeDragDropPushMessageEvent = {
        type: "COMPONENT_TYPE_DRAG_DROP";
        componentTypeName: EditorComponentTypeName;
    };

    type ComponentTypeDragEndPushMessageEvent = {
        type: "COMPONENT_TYPE_DRAG_END";
        componentTypeName: EditorComponentTypeName;
    };

    type ComponentTypeDragStartPushMessageEvent = {
        type: "COMPONENT_TYPE_DRAG_START";
        componentTypeName: EditorComponentTypeName;
    };

    type ComponentTypeDragOverPushMessageEvent = {
        type: "COMPONENT_TYPE_DRAG_OVER";
        componentTypeName: EditorComponentTypeName;
        coords: Coords;
    };

    // #region Values

    const toolboxSubMenuTab = ref<string>("");
    const editorIFrameProjector = ref<InstanceType<typeof IFrameProjector> | undefined>();
    const isEditorOverlayVisible = ref<boolean>(false);
    const draggingComponentType = ref<EditorComponentType | null | undefined>();
    const draggingComponentPlaceholderElement = ref<HTMLElement | null | undefined>();
    const sectionCategory = ref<string>("");
    const sectionCategories = ref<ListItemBag[]>([]);

    // #endregion

    // #region Computed Values

    const toolboxSubMenuTabs = computed<string[]>(() => {
        return [
            "Components",
            "Sections"
        ];
    });

    const editorWidthPixels = computed<string>(() => {
        return `${editorWidth}px`;
    });

    const editorHeightPixels = computed<string>(() => {
        return `${editorHeight}px`;
    });

    const componentTypes: EditorComponentType[] = [
        titleComponent,
        videoComponent,
        buttonComponent,
        paragraphComponent,
        dividerComponent,
        messageComponent,
        imageComponent,
        lavaComponent,
        rsvpComponent,
    ];

    // #endregion

    // #region Event Handlers

    /**
     * Handles a component type starting to be dragged in the parent window
     * and passes arguments to the child editor iframe to handle the event in the editor.
     */
    function onComponentTypeDragStart(_event: DragEvent, componentType: EditorComponentType): void {
        draggingComponentType.value = componentType;

        const e: ComponentTypeDragStartPushMessageEvent = {
            type: "COMPONENT_TYPE_DRAG_START",
            componentTypeName: componentType.typeName
        };

        // Tell the editor iframe that a component type is starting to be dragged (whether or not the component type is over it).
        editorIFrameProjector.value?.iframe?.contentWindow?.postMessage(e, "/");

        // Show the editor overlay when a component type starts being dragged
        // so it can capture the dragover and drop events.
        isEditorOverlayVisible.value = true;
    }

    function onIFrameComponentTypeDragStart(e: ComponentTypeDragStartPushMessageEvent): void {
        const iframeDocument = editorIFrameProjector.value?.iframe?.contentDocument;

        if (!iframeDocument) {
            throw "The iframe document has not been initialized.";
        }

        // When dragging starts, create a temporary placeholder element that will be moved around
        // the editor iframe. The handler for the "dragover" event,
        // which is fired repetitively even if the pointer is stationary,
        // will handle moving the placeholder element to the correct location.
        draggingComponentPlaceholderElement.value = getComponentOrThrow(e.componentTypeName).createComponentPlaceholder(iframeDocument);
    }

    /**
     * Handles a component type being dragged over the parent window's editor overlay
     * and passes arguments to the child editor iframe to handle the event.
     *
     * FYI, the "dragover" event is fired repetitively even if the pointer is stationary,
     * so this handler will be invoked many times.
     */
    function onComponentTypeDragOver(e: DragEvent, componentType: EditorComponentType): void {
        // Preventing default here makes the element a valid drop target.
        e.preventDefault();

        // Get the mouse coordinates relative to the iframe
        // (using the overlay in this case since it should have the same width and height as the iframe).
        // The iframe x and y coordinates will be passed to the iframe
        // so it can process which element(s) are currently being dragged over.
        const coords = getRelativeCoordinates(e.target as HTMLElement, e.pageX, e.pageY);

        const event: ComponentTypeDragOverPushMessageEvent = {
            type: "COMPONENT_TYPE_DRAG_OVER",
            coords,
            componentTypeName: componentType.typeName
        };

        // Tell the editor iframe that a component type is being dragged over it.
        editorIFrameProjector.value?.iframe?.contentWindow?.postMessage(event, "/");
    }

    function onIFrameComponentTypeDragOver(e: ComponentTypeDragOverPushMessageEvent): void {
        if (!draggingComponentPlaceholderElement.value) {
            return;
        }

        // This handler will place the current component type's placeholder element
        // either before or after the element being hovered over.

        // TODO JMH This should probably add a mousemove event handler since dragover occurs non-stop and may affect performance.
        const elementsOver = (editorIFrameProjector.value?.iframe?.contentDocument?.elementsFromPoint(e.coords.x, e.coords.y) ?? []) as HTMLElement[];

        // Find the first hovered-over element whose parent is a dropzone,
        // and move the placeholder either before or after it.
        // FYI, elementsOver is sorted from descendant element to ancestor element.
        for (const elementOver of elementsOver) {
            if (elementOver.parentElement?.matches(".dropzone")) {
                const elementOverMidpointY = (elementOver.offsetHeight / 2) + elementOver.offsetTop;

                // If the current mouse position is less than this midpoint,
                // then the new element should be placed before it.
                if (e.coords.y < elementOverMidpointY) {
                    elementOver.parentElement.insertBefore(draggingComponentPlaceholderElement.value, elementOver);
                }
                // ... otherwise, the new element should be placed after it.
                else {
                    elementOver.parentElement.insertBefore(draggingComponentPlaceholderElement.value, elementOver.nextSibling);
                }

                return;
            }
            else if (elementOver.matches(".dropzone")) {
                // TODO JMH Add case where dropping in dropzone but not on top of another child.
                // TODO JMH For now, just put the element as the last child.
                elementOver.appendChild(draggingComponentPlaceholderElement.value);
            }
        }
    }

    /**
     * Handles a component type being dropped on the editor overlay
     * and passes arguments to the child editor iframe to handle the event.
     *
     * This should ultimately add the component type to the editor.
     */
    function onComponentTypeDragDrop(_event: DragEvent, componentType: EditorComponentType): void {
        const e: ComponentTypeDragDropPushMessageEvent = {
            type: "COMPONENT_TYPE_DRAG_DROP",
            componentTypeName: componentType.typeName
        };

        // Tell the editor iframe that the component type was dropped into it.
        editorIFrameProjector.value?.iframe?.contentWindow?.postMessage(e, "/");
    }

    function onIFrameComponentTypeDragDrop(e: ComponentTypeDragDropPushMessageEvent): void {
        const iframeDocument = editorIFrameProjector.value?.iframe?.contentDocument;

        if (!iframeDocument) {
            throw "Error processing the drop operation in the editor";
        }
        else if (!draggingComponentPlaceholderElement.value) {
            console.log("Nothing to drop");
        }
        else {
            const componentElement = getComponentOrThrow(e.componentTypeName).createComponentElement(iframeDocument);

            // Swap the placeholder element with the permanent element.
            draggingComponentPlaceholderElement.value.replaceWith(componentElement);

            // Set the dragging element to null to keep it in the DOM.
            draggingComponentPlaceholderElement.value = null;
        }
    }

    /**
     * Handles a component type stopping being dragged
     * and passes arguments to the child editor iframe to handle the event.
     *
     * This is the last event that is occurs in the drag-drop cycle.
     */
    function onComponentTypeDragEnd(_event: DragEvent, componentType: EditorComponentType): void {
        const e: ComponentTypeDragEndPushMessageEvent = {
            type: "COMPONENT_TYPE_DRAG_END",
            componentTypeName: componentType.typeName
        };

        // Tell the editor iframe that the component type is no longer being dragged (whether or not it was "dropped").
        editorIFrameProjector.value?.iframe?.contentWindow?.postMessage(e, "/");

        // Remove the editor overlay in the parent window.
        isEditorOverlayVisible.value = false;
    }

    function onIFrameComponentTypeDragEnd(): void {
        // If "dragend" happens and there was never a "drop",
        // then remove the temporary dragging element from the DOM.
        if (draggingComponentPlaceholderElement.value) {
            draggingComponentPlaceholderElement.value.remove();
            draggingComponentPlaceholderElement.value = null;
        }
    }

    /**
     * Handles a component type stopping being dragged
     * and passes arguments to the child editor iframe to handle the event.
     *
     * This is the last event that is occurs in the drag-drop cycle.
     */
    function onComponentTypeDragLeave(_event: DragEvent, componentType: EditorComponentType): void {
        const e: ComponentTypeDragLeavePushMessageEvent = {
            type: "COMPONENT_TYPE_DRAG_LEAVE",
            componentTypeName: componentType.typeName
        };

        // Tell the editor iframe that the component type has been dragged outside of the its border.
        editorIFrameProjector.value?.iframe?.contentWindow?.postMessage(e, "/");
    }

    function onIFrameComponentTypeDragLeave(): void {
        // If "dragleave" happens then remove the temporary dragging element from the DOM.
        if (draggingComponentPlaceholderElement.value) {
            draggingComponentPlaceholderElement.value.remove();
        }
    }

    /**
     * Handles all messages communicated from the parent window to the editor iframe,
     * such as components or sections being dragged from the toolbox to the editor.
     */
    function onIFrameMessagePushed(event: MessageEvent<
        ComponentTypeDragDropPushMessageEvent
        | ComponentTypeDragOverPushMessageEvent
        | ComponentTypeDragEndPushMessageEvent
        | ComponentTypeDragStartPushMessageEvent
        | ComponentTypeDragLeavePushMessageEvent>): void {
        switch (event.data.type) {
            case "COMPONENT_TYPE_DRAG_START":
                onIFrameComponentTypeDragStart(event.data);
                break;

            case "COMPONENT_TYPE_DRAG_OVER":
                onIFrameComponentTypeDragOver(event.data);
                break;

            case "COMPONENT_TYPE_DRAG_LEAVE":
                onIFrameComponentTypeDragLeave();
                break;

            case "COMPONENT_TYPE_DRAG_DROP":
                onIFrameComponentTypeDragDrop(event.data);
                break;

            case "COMPONENT_TYPE_DRAG_END":
                onIFrameComponentTypeDragEnd();
                break;
        }
    }

    /**
     * Handles the editor iframe being loaded.
     *
     * This is a good time to add initial, temporary elements
     * to the editor, like CSS, fonts, etc., but they should
     * be removed before saving the email communication message.
     */
    function onIFrameLoaded(): void {
        const iframe = editorIFrameProjector.value?.iframe;
        // TODO JMH Add Rock fonts for access to font-awesome icons?
        if (iframe?.contentDocument) {
            // var cssLink = document.createElement("link");
            // cssLink.className = "js-emaileditor2-addon";
            // cssLink.href = `/Themes/Rock/Styles/email-editor.css?v=${Date.now()}`;
            // cssLink.rel = "stylesheet";
            // cssLink.type = "text/css";
            // iframe.contentDocument.head.appendChild(cssLink);

            var style = document.createElement("style");
            style.className = "js-emaileditor2-addon";
            style.textContent = `
.dropzone:empty {
    position: relative;
    padding: 30px;
    outline: 2px dashed rgba(0, 0, 0, 0.3);
    outline-offset: -3px;
    min-height: 22px;
}

.dropzone:empty::after {
    position: absolute;
    top: 50%;
    left: 0;
    display: block;
    width: 100%;
    font-size: 10px;
    color: rgba(0, 0, 0, 0.3);
    text-align: center;
    content: "Drop component here";
    transform: translateY(-50%);
}
`;
            iframe.contentDocument.head.appendChild(style);
        }
    }

    /**
     * Handles the mouse being down within the editor iframe.
     *
     * This will enable dragging behavior
     */
    function onIFrameMouseDown(event: MouseEvent): void {
        // When the mouse is down in the editor iframe,
        // find the nearest component element (or component ancestor element)
        // where the mouse currently is, and allow it to be dragged/moved to another
        // dropzone. This is as simple as adding the "draggable" attribute to the element
        // while the mouse is down.
        const component = (event.target as HTMLElement)?.closest(".component") as HTMLElement;

        if (component) {
            component.addEventListener("dragend", onIFrameComponentDragEnd);
            component.setAttribute("draggable", "true");
        }
    }

    function onIFrameComponentDragEnd(event: DragEvent): void {
        const componentElement = event.target as HTMLElement;

        if (componentElement) {
            // When dragging is finished, remove the "draggable" attribute from the
            // component so it isn't left draggable in the resulting email content.
            // Also remove this function as an event listener to keep event system clean.
            componentElement.removeEventListener("dragend", onIFrameComponentDragEnd);
            componentElement.removeAttribute("draggable");
        }
    }

    // #endregion

    // #region Functions

    function getRelativeCoordinates(element: HTMLElement, pageX: number, pageY: number): Coords {
        const rect = element.getBoundingClientRect();
        const x = pageX - rect.x;
        const y = pageY - rect.y;

        return { x, y };
    }

    // #endregion

    // #region Hooks

    onMounted(() => {
        // Add drag handlers.

        // The iframe should be accessible at this point
        // so add event handlers.
        const iframe = editorIFrameProjector.value?.iframe;
        if (iframe?.contentWindow) {
            iframe.contentWindow.addEventListener("message", onIFrameMessagePushed);
            iframe.contentWindow.addEventListener("load", onIFrameLoaded);

            // Add handler that allows moving components inside the editor.
            iframe.contentWindow.addEventListener("mousedown", onIFrameMouseDown);
        }
        else {
            console.error("An error occurred while loading the editor.");
        }
    });

    onBeforeUnmount(() => {
        const iframe = editorIFrameProjector.value?.iframe;
        if (iframe?.contentWindow) {
            iframe.contentWindow.removeEventListener("message", onIFrameMessagePushed);
            iframe.contentWindow.removeEventListener("load", onIFrameLoaded);
            iframe.contentWindow.removeEventListener("mousedown", onIFrameMouseDown);
        }
    });

    // #endregion
</script>
