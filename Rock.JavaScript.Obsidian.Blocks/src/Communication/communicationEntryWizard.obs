<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Panel :hasFullscreen="true"
           :headerSecondaryActions="[{
               title: 'TBD', type: 'default'
           }]"
           panelClass="communication-entry-wizard-editor-panel">
        <template #title>
            <div class="communication-entry-wizard-editor-panel-title">
                <span>Email Editor</span>
                <HighlightLabel>1234 Recipients</HighlightLabel>
            </div>
        </template>

        <template #subheaderRight>
            <div>
                <RockButton class="communication-entry-wizard-editor-subheader-action" btnSize="xs">Send Test</RockButton>
                <RockButton class="communication-entry-wizard-editor-subheader-action" btnSize="xs">Preview</RockButton>
                <RockButton class="communication-entry-wizard-editor-subheader-action" btnSize="xs">Save</RockButton>
            </div>
        </template>

        <template #default>
            <div class="communication-entry-wizard-editor-panel-body">
                <div class="communication-entry-wizard-editor-toolbox">
                    <div class="communication-entry-wizard-editor-toolbox-menu">

                    </div>

                    <div class="communication-entry-wizard-editor-toolbox-submenu">
                        <TabbedContent v-model="toolboxSubMenuTab" :tabs="toolboxSubMenuTabs">
                            <template #tabpane="{ item }">
                                <div v-if="item === 'Components'" class="component-list">
                                    <div v-for="component in components"
                                         :key="component.type"
                                         class="component-list-item draggable"
                                         draggable="true"
                                         @dragstart="onDragStart($event, component)"
                                         @dragend="onDragEnd($event, component)"><i :class="component.iconCssClass"></i>{{ component.name }}</div>
                                </div>
                            </template>
                        </TabbedContent>
                    </div>
                </div>

                <div class="communication-entry-wizard-editor-content-container">
                    <IFrameProjector ref="iframeProjector" :width="editorWidth" :height="editorHeight" frameborder="0" border="0">
                        <!DOCTYPE html>
                        <html>

                        <head>
                        </head>

                        <body>
                            <div style="display: flex; flex-direction: row;">
                                <div class="dropzone" style="flex-grow: 1; background-color: lightblue;">
                                    <p>this is in dropzone 1</p>
                                </div>
                                <div class="dropzone" style="flex-grow: 1; background-color: lightseagreen;">
                                    <p>this is in dropzone 2</p>
                                </div>
                            </div>
                        </body>

                        </html>
                    </IFrameProjector>
                    <div v-if="isEditorOverlayVisible && draggingComponent"
                         class="communication-entry-wizard-editor-overlay"
                         @dragover="onDragOver($event, draggingComponent)"
                         @drop="onDragDrop($event, draggingComponent)"></div>
                </div>
            </div>
        </template>

        <template #footerActions>
            <RockButton>Previous</RockButton>
        </template>

        <template #footerSecondaryActions>
            <RockButton btnType="primary">Next</RockButton>
        </template>
    </Panel>
</template>

<style scoped>
.communication-entry-wizard-editor-content-container {
    position: relative;
    width: v-bind(editorWidthPixels);
    height: v-bind(editorHeightPixels);
}

.communication-entry-wizard-editor-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: v-bind(editorWidthPixels);
    height: v-bind(editorHeightPixels);
    opacity: 0.4;
    background-color: orange;
}

.draggable {
    cursor: grab;
}

.draggable:active {
    cursor: grabbing;
}

.component-list {
    columns: 3;
}

.component-list-item {
    display: flex;
    flex-direction: column;
    width: 86px;
    height: 74px;
    text-align: center;
    align-items: center;
    border: 1px solid;
    border-color: var(--color-primary);
}

.communication-entry-wizard-editor-toolbox {
    display: flex;
    flex-wrap: wrap;
}

.communication-entry-wizard-editor-toolbox-menu {
    display: flex;
    flex-direction: column;
}

.communication-entry-wizard-editor-toolbox-submenu {
    display: flex;
    flex-direction: column;
    width: 300px;
}

.communication-entry-wizard-editor-panel-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.communication-entry-wizard-editor-subheader-action + .communication-entry-wizard-editor-subheader-action {
    margin-left: 16px;
}

.communication-entry-wizard-editor-panel-body {
    min-height: 300px;
    display: flex;
}
</style>

<script setup lang="ts">
    import { computed, onBeforeUnmount, onMounted, ref } from "vue";
    import IFrameProjector from "./CommunicationWizard/iframeProjector.partial.obs";
    import { EditorComponent, EditorComponentType } from "./CommunicationWizard/types.partial";
    import HighlightLabel from "@Obsidian/Controls/highlightLabel.obs";
    import Panel from "@Obsidian/Controls/panel.obs";
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import TabbedContent from "@Obsidian/Controls/tabbedContent.obs";
    import { buttonComponent, dividerComponent, getComponentOrThrow, imageComponent, lavaComponent, messageComponent, paragraphComponent, rsvpComponent, titleComponent, videoComponent } from "./CommunicationWizard/components.partial";

    const editorWidth = 500;
    const editorHeight = 500;

    type Coords = {
        x: number;
        y: number;
    };

    type DragDropPushMessageEvent = {
        type: "dragdrop";
        componentType: EditorComponentType;
    };

    type DragEndPushMessageEvent = {
        type: "dragend";
        componentType: EditorComponentType;
    };

    type DragStartPushMessageEvent = {
        type: "dragstart";
        componentType: EditorComponentType;
    };

    type DragOverPushMessageEvent = {
        type: "dragover";
        componentType: EditorComponentType;
        coords: Coords;
    };

    // #region Values

    const toolboxSubMenuTab = ref<string>("");
    const iframeProjector = ref<InstanceType<typeof IFrameProjector> | undefined>();
    const isEditorOverlayVisible = ref<boolean>(false);
    const draggingComponent = ref<EditorComponent | null | undefined>();
    const draggingComponentPlaceholderElement = ref<HTMLElement | null | undefined>();

    // #endregion

    // #region Computed Values

    const toolboxSubMenuTabs = computed<string[]>(() => {
        return [
            "Components",
            "Sections"
        ];
    });

    const editorWidthPixels = computed<string>(() => {
        return `${editorWidth}px`;
    });

    const editorHeightPixels = computed<string>(() => {
        return `${editorHeight}px`;
    });

    const components: EditorComponent[] = [
        titleComponent,
        videoComponent,
        buttonComponent,
        paragraphComponent,
        dividerComponent,
        messageComponent,
        imageComponent,
        lavaComponent,
        rsvpComponent,
    ];

    // #endregion

    // #region Event Handlers

    /**
     * Handles a component starting to be dragged in the parent window
     * and passes arguments to the child editor iframe to handle the event in the editor.
     */
    function onDragStart(_event: DragEvent, component: EditorComponent): void {
        draggingComponent.value = component;

        // Tell the iframe that a drag start occurred.
        sendDragStartMessageToEditorIFrame(component);

        // Show the editor overlay when a component starts being dragged
        // so it can capture the dragover and drop events.
        isEditorOverlayVisible.value = true;
    }

    function onIFrameDragStart(e: DragStartPushMessageEvent): void {
        const iframeDocument = iframeProjector.value?.iframe?.contentDocument;

        if (!iframeDocument) {
            throw "The iframe document has not been initialized.";
        }

        // When dragging starts, create a temporary placeholder element that will be moved around
        // the editor iframe as the "dragover" event is fired.
        draggingComponentPlaceholderElement.value = getComponentOrThrow(e.componentType).createPlaceholder(iframeDocument);
    }

    /**
     * Handles a component being dragged over the parent window's editor overlay
     * and passes arguments to the child editor iframe to handle the event.
     */
    function onDragOver(event: DragEvent, component: EditorComponent): void {
        // Preventing default here makes the element a valid drop target.
        // "dragover" is fired continuously.
        event.preventDefault();

        // Get the mouse coordinates relative to the iframe
        // (using the overlay in this case since it should have the same width and height as the iframe).
        // The iframe x and y coordinates will be passed to the iframe
        // so it can process which element(s) are currently being dragged over.
        const coords = getRelativeCoordinates(event.target as HTMLElement, event.pageX, event.pageY);

        // Tell the iframe that a drag over occurred.
        sendDragOverMessageToEditorIFrame(component, coords);
    }

    function onIFrameDragOver(e: DragOverPushMessageEvent): void {
        if (!draggingComponentPlaceholderElement.value) {
            return;
        }

        // Figure out between which iframe body elements the component/section is being drag-dropped,
        // then insert the new placeholder element between them.

        // TODO JMH This should probably add a mousemove event handler since dragover occurs non-stop and may affect performance.
        const elementsOver = (iframeProjector.value?.iframe?.contentDocument?.elementsFromPoint(e.coords.x, e.coords.y) ?? []) as HTMLElement[];

        // The elements are in order from child to parent.
        // Of the elements at this point, find the first ancestor that is a dropzone.
        for (const elementOver of elementsOver) {
            if (elementOver.parentElement?.matches(".dropzone")) {
                // Over another draggable element. Figure out whether the new element should be added before or after.
                const midpoint = (elementOver.offsetHeight / 2) + elementOver.offsetTop;

                // If the current mouse position is less than this midpoint,
                // then the new element should be placed before.
                if (e.coords.y < midpoint) {
                    elementOver.parentElement.insertBefore(draggingComponentPlaceholderElement.value, elementOver);
                }
                // ... otherwise, the new element should be placed after.
                else {
                    elementOver.parentElement.insertBefore(draggingComponentPlaceholderElement.value, elementOver.nextSibling);
                }
            }
        }
    }

    /**
     * Handles a component being dropped on the editor overlay
     * and passes arguments to the child editor iframe to handle the event.
     *
     * This should ultimately add the component to the editor.
     */
    function onDragDrop(_event: DragEvent, component: EditorComponent): void {
        // Tell the iframe that a drop occurred.
        sendDragDropInfoToEditorIFrame(component);
    }

    function onIFrameDragDrop(e: DragDropPushMessageEvent): void {
        const iframeDocument = iframeProjector.value?.iframe?.contentDocument;

        if (!iframeDocument) {
            throw "Error processing the drop operation in the editor";
        }
        else if (!draggingComponentPlaceholderElement.value) {
            console.log("Nothing to drop");
        }
        else {
            const componentElement = getComponentOrThrow(e.componentType).createElement(iframeDocument);

            // Swap the placeholder element with the permanent element.
            draggingComponentPlaceholderElement.value.replaceWith(componentElement);

            // Set the dragging element to null to keep it in the DOM.
            draggingComponentPlaceholderElement.value = null;
        }
    }

    /**
     * Handles a component stopping being dragged
     * and passes arguments to the child editor iframe to handle the event.
     *
     * This is the last event that is occurs in the drag-drop cycle.
     */
    function onDragEnd(_event: DragEvent, component: EditorComponent): void {
        // Tell the iframe that a drag end occurred.
        sendDragEndInfoToEditorIFrame(component);

        // Update the parent window.
        isEditorOverlayVisible.value = false;
    }

    function onIFrameDragEnd(): void {
        // If "dragend" happens and there was never a "drop",
        // then remove the temporary dragging element from the DOM.
        if (draggingComponentPlaceholderElement.value) {
            draggingComponentPlaceholderElement.value.remove();
            draggingComponentPlaceholderElement.value = null;
        }
    }

    /**
     * Handles all messages communicated from the parent window to the editor iframe
     * such as components or sections being dragged from the toolbox to the editor.
     */
    function onIFrameMessagePushed(event: MessageEvent<DragDropPushMessageEvent | DragOverPushMessageEvent | DragEndPushMessageEvent | DragStartPushMessageEvent>): void {
        switch (event.data.type) {
            case "dragstart":
                onIFrameDragStart(event.data);
                break;

            case "dragover":
                onIFrameDragOver(event.data);
                break;

            case "dragdrop":
                onIFrameDragDrop(event.data);
                break;

            case "dragend":
                onIFrameDragEnd();
                break;
        }
    }

    // #endregion

    // #region Functions

    function getRelativeCoordinates(element: HTMLElement, pageX: number, pageY: number): Coords {
        const rect = element.getBoundingClientRect();
        const x = pageX - rect.x;
        const y = pageY - rect.y;

        return { x, y };
    }

    function sendDragStartMessageToEditorIFrame(component: EditorComponent): void {
        const e: DragStartPushMessageEvent = {
            type: "dragstart",
            componentType: component.type
        };

        iframeProjector.value?.iframe?.contentWindow?.postMessage(e, "/");
    }

    function sendDragOverMessageToEditorIFrame(component: EditorComponent, coords: Coords): void {
        const event: DragOverPushMessageEvent = {
            type: "dragover",
            coords,
            componentType: component.type
        };

        iframeProjector.value?.iframe?.contentWindow?.postMessage(event, "/");
    }

    function sendDragDropInfoToEditorIFrame(component: EditorComponent): void {
        const e: DragDropPushMessageEvent = {
            type: "dragdrop",
            componentType: component.type
        };

        iframeProjector.value?.iframe?.contentWindow?.postMessage(e, "/");
    }

    function sendDragEndInfoToEditorIFrame(component: EditorComponent): void {
        const e: DragEndPushMessageEvent = {
            type: "dragend",
            componentType: component.type
        };

        iframeProjector.value?.iframe?.contentWindow?.postMessage(e, "/");
    }

    // #endregion

    // #region Hooks

    onMounted(() => {
        // Add drag handlers.

        // The iframe should be accessible at this point
        // so add event handlers.
        const iframe = iframeProjector.value?.iframe;
        if (iframe?.contentWindow) {
            iframe.contentWindow.addEventListener("message", onIFrameMessagePushed);
        }
        else {
            console.error("An error occurred while loading the editor.");
        }
    });

    onBeforeUnmount(() => {
        const iframe = iframeProjector.value?.iframe;
        if (iframe?.contentWindow) {
            iframe.contentWindow.removeEventListener("message", onIFrameMessagePushed);
        }
    });

    // #endregion
</script>
